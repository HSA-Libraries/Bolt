<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>Bolt: bolt::cl::device_vector&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Bolt
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">C++ template library with support for OpenCL</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacebolt.html">bolt</a></li><li class="navelem"><a class="el" href="namespacebolt_1_1cl.html">cl</a></li><li class="navelem"><a class="el" href="classbolt_1_1cl_1_1device__vector.html">device_vector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classbolt_1_1cl_1_1device__vector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">bolt::cl::device_vector&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This defines the OpenCL version of a <a class="el" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">device_vector</a>.  
 <a href="classbolt_1_1cl_1_1device__vector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cl_2device__vector_8h_source.html">device_vector.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector_1_1iterator__base.html">iterator_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class provided to encapsulate all the common functionality for constant and non-constant iterators.  <a href="classbolt_1_1cl_1_1device__vector_1_1iterator__base.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector_1_1reference__base.html">reference_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A writeable element of the container The location of an element of the container may not actually reside in system memory, but rather in device memory, which may be in a partitioned memory space. Access to a reference of the container results in a mapping and unmapping operation of device memory.  <a href="classbolt_1_1cl_1_1device__vector_1_1reference__base.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector_1_1reverse__iterator__base.html">reverse_iterator_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reverse random access iterator in the classic sense.  <a href="classbolt_1_1cl_1_1device__vector_1_1reverse__iterator__base.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aaae3c93d7988ef9cf43846ec5ac71a89"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaae3c93d7988ef9cf43846ec5ac71a89"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="separator:aaae3c93d7988ef9cf43846ec5ac71a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8689385ae9214de744c361b680bba8d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8689385ae9214de744c361b680bba8d6"></a>
typedef ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr class="separator:a8689385ae9214de744c361b680bba8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab653a8b09f4e2c7bcdaa77864bff281e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab653a8b09f4e2c7bcdaa77864bff281e"></a>
typedef difference_type&#160;</td><td class="memItemRight" valign="bottom"><b>distance_type</b></td></tr>
<tr class="separator:ab653a8b09f4e2c7bcdaa77864bff281e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ebd4946e9e64921a64c20a10facd592"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ebd4946e9e64921a64c20a10facd592"></a>
typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:a0ebd4946e9e64921a64c20a10facd592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6204f6f43a5506367ea2fd69e225e5a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6204f6f43a5506367ea2fd69e225e5a3"></a>
typedef boost::shared_array<br class="typebreak"/>
&lt; value_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b></td></tr>
<tr class="separator:a6204f6f43a5506367ea2fd69e225e5a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98f7d99fc4ee29d20fd7ff16cee8afcb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98f7d99fc4ee29d20fd7ff16cee8afcb"></a>
typedef boost::shared_array<br class="typebreak"/>
&lt; const value_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b></td></tr>
<tr class="separator:a98f7d99fc4ee29d20fd7ff16cee8afcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0845c082f9128d4e89ab30037103bcf2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0845c082f9128d4e89ab30037103bcf2"></a>
typedef <a class="el" href="classbolt_1_1cl_1_1device__vector_1_1reference__base.html">reference_base</a><br class="typebreak"/>
&lt; <a class="el" href="classbolt_1_1cl_1_1device__vector.html">device_vector</a>&lt; value_type &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a0845c082f9128d4e89ab30037103bcf2">reference</a></td></tr>
<tr class="memdesc:a0845c082f9128d4e89ab30037103bcf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef to create the non-constant reference. <br/></td></tr>
<tr class="separator:a0845c082f9128d4e89ab30037103bcf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a53b6416da92e99626e64ff9eb97616"><td class="memItemLeft" align="right" valign="top">typedef const value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a2a53b6416da92e99626e64ff9eb97616">const_reference</a></td></tr>
<tr class="memdesc:a2a53b6416da92e99626e64ff9eb97616"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-writeable copy of an element of the container. Constant references are optimized to return a value_type, since it is certain that the value will not be modified.  <a href="#a2a53b6416da92e99626e64ff9eb97616"></a><br/></td></tr>
<tr class="separator:a2a53b6416da92e99626e64ff9eb97616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c531350e4e69702b01b6e1cb22fecd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1c531350e4e69702b01b6e1cb22fecd"></a>
typedef <a class="el" href="classbolt_1_1cl_1_1device__vector_1_1iterator__base.html">iterator_base</a><br class="typebreak"/>
&lt; <a class="el" href="classbolt_1_1cl_1_1device__vector.html">device_vector</a>&lt; value_type &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#ad1c531350e4e69702b01b6e1cb22fecd">iterator</a></td></tr>
<tr class="memdesc:ad1c531350e4e69702b01b6e1cb22fecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef to create the non-constant iterator. <br/></td></tr>
<tr class="separator:ad1c531350e4e69702b01b6e1cb22fecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad113d8217364ce718b6d1e012a4c378b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad113d8217364ce718b6d1e012a4c378b"></a>
typedef <a class="el" href="classbolt_1_1cl_1_1device__vector_1_1iterator__base.html">iterator_base</a>&lt; const <br class="typebreak"/>
<a class="el" href="classbolt_1_1cl_1_1device__vector.html">device_vector</a>&lt; value_type &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#ad113d8217364ce718b6d1e012a4c378b">const_iterator</a></td></tr>
<tr class="memdesc:ad113d8217364ce718b6d1e012a4c378b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef to create the constant iterator. <br/></td></tr>
<tr class="separator:ad113d8217364ce718b6d1e012a4c378b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e424505b6f3d034429d6959f3b6b1a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e424505b6f3d034429d6959f3b6b1a1"></a>
typedef <a class="el" href="classbolt_1_1cl_1_1device__vector_1_1reverse__iterator__base.html">reverse_iterator_base</a><br class="typebreak"/>
&lt; <a class="el" href="classbolt_1_1cl_1_1device__vector.html">device_vector</a>&lt; value_type &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a1e424505b6f3d034429d6959f3b6b1a1">reverse_iterator</a></td></tr>
<tr class="memdesc:a1e424505b6f3d034429d6959f3b6b1a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef to create the non-constant reverse iterator. <br/></td></tr>
<tr class="separator:a1e424505b6f3d034429d6959f3b6b1a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15fb87576fc9597557aa65e6e15ac18e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15fb87576fc9597557aa65e6e15ac18e"></a>
typedef <a class="el" href="classbolt_1_1cl_1_1device__vector_1_1reverse__iterator__base.html">reverse_iterator_base</a><br class="typebreak"/>
&lt; const <a class="el" href="classbolt_1_1cl_1_1device__vector.html">device_vector</a><br class="typebreak"/>
&lt; value_type &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a15fb87576fc9597557aa65e6e15ac18e">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a15fb87576fc9597557aa65e6e15ac18e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef to create the constant reverse iterator. <br/></td></tr>
<tr class="separator:a15fb87576fc9597557aa65e6e15ac18e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a01c1f40015e9b9f8699cf92c40cfa3a0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a01c1f40015e9b9f8699cf92c40cfa3a0">device_vector</a> (const <a class="el" href="classbolt_1_1cl_1_1control.html">control</a> &amp;ctl=<a class="el" href="group__CL-control.html#ga59712ff5a77d3714f716d85938705289">control::getDefault</a>())</td></tr>
<tr class="memdesc:a01c1f40015e9b9f8699cf92c40cfa3a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default constructor that creates an empty <a class="el" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">device_vector</a>.  <a href="#a01c1f40015e9b9f8699cf92c40cfa3a0"></a><br/></td></tr>
<tr class="separator:a01c1f40015e9b9f8699cf92c40cfa3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c551cec5c2827064d8c193b6853044c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a0c551cec5c2827064d8c193b6853044c">device_vector</a> (size_type newSize, const value_type &amp;value=value_type(), cl_mem_flags flags=CL_MEM_READ_WRITE, bool init=true, const <a class="el" href="classbolt_1_1cl_1_1control.html">control</a> &amp;ctl=<a class="el" href="group__CL-control.html#ga59712ff5a77d3714f716d85938705289">control::getDefault</a>())</td></tr>
<tr class="memdesc:a0c551cec5c2827064d8c193b6853044c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constructor that creates a new <a class="el" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">device_vector</a> with the specified number of elements, with a specified initial value.  <a href="#a0c551cec5c2827064d8c193b6853044c"></a><br/></td></tr>
<tr class="separator:a0c551cec5c2827064d8c193b6853044c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f808e7079196f70ec996eac9a014ae1"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a1f808e7079196f70ec996eac9a014ae1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a1f808e7079196f70ec996eac9a014ae1">device_vector</a> (const InputIterator <a class="el" href="classbolt_1_1cl_1_1device__vector.html#adcfa66f58ba75564ab14482c5934ee87">begin</a>, size_type newSize, cl_mem_flags flags=CL_MEM_READ_WRITE, bool init=true, const <a class="el" href="classbolt_1_1cl_1_1control.html">control</a> &amp;ctl=<a class="el" href="group__CL-control.html#ga59712ff5a77d3714f716d85938705289">control::getDefault</a>(), typename std::enable_if&lt; !std::is_integral&lt; InputIterator &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:a1f808e7079196f70ec996eac9a014ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constructor that creates a new <a class="el" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">device_vector</a> using a range specified by the user.  <a href="#a1f808e7079196f70ec996eac9a014ae1"></a><br/></td></tr>
<tr class="separator:a1f808e7079196f70ec996eac9a014ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb6977424f13ec0758b2c74f6b637c1"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:adcb6977424f13ec0758b2c74f6b637c1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#adcb6977424f13ec0758b2c74f6b637c1">device_vector</a> (const InputIterator <a class="el" href="classbolt_1_1cl_1_1device__vector.html#adcfa66f58ba75564ab14482c5934ee87">begin</a>, const InputIterator <a class="el" href="classbolt_1_1cl_1_1device__vector.html#a21179fdc21dd47292b865bd064975fd2">end</a>, cl_mem_flags flags=CL_MEM_READ_WRITE, const <a class="el" href="classbolt_1_1cl_1_1control.html">control</a> &amp;ctl=<a class="el" href="group__CL-control.html#ga59712ff5a77d3714f716d85938705289">control::getDefault</a>(), typename std::enable_if&lt; !std::is_integral&lt; InputIterator &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:adcb6977424f13ec0758b2c74f6b637c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constructor that creates a new <a class="el" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">device_vector</a> using a range specified by the user.  <a href="#adcb6977424f13ec0758b2c74f6b637c1"></a><br/></td></tr>
<tr class="separator:adcb6977424f13ec0758b2c74f6b637c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba05b856ae25b393d0b781cac71599b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#acba05b856ae25b393d0b781cac71599b">device_vector</a> (const ::cl::Buffer &amp;rhs, const <a class="el" href="classbolt_1_1cl_1_1control.html">control</a> &amp;ctl=<a class="el" href="group__CL-control.html#ga59712ff5a77d3714f716d85938705289">control::getDefault</a>())</td></tr>
<tr class="memdesc:acba05b856ae25b393d0b781cac71599b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constructor that creates a new <a class="el" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">device_vector</a> using a pre-initialized buffer supplied by the user.  <a href="#acba05b856ae25b393d0b781cac71599b"></a><br/></td></tr>
<tr class="separator:acba05b856ae25b393d0b781cac71599b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c79608b7809ec6e256f8c74888e8c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51c79608b7809ec6e256f8c74888e8c3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>device_vector</b> (const <a class="el" href="classbolt_1_1cl_1_1device__vector.html">device_vector</a> &amp;rhs)</td></tr>
<tr class="separator:a51c79608b7809ec6e256f8c74888e8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b57d2921dc50f4a58217531b549f91"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3b57d2921dc50f4a58217531b549f91"></a>
<a class="el" href="classbolt_1_1cl_1_1device__vector.html">device_vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classbolt_1_1cl_1_1device__vector.html">device_vector</a> &amp;rhs)</td></tr>
<tr class="separator:ab3b57d2921dc50f4a58217531b549f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883425a12e6bb517419e14b0e4a5b912"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a883425a12e6bb517419e14b0e4a5b912">resize</a> (size_type reqSize, const value_type &amp;val=value_type())</td></tr>
<tr class="memdesc:a883425a12e6bb517419e14b0e4a5b912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the number of elements in <a class="el" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">device_vector</a> to reqSize. If the new requested size is less than the original size, the data is truncated and lost. If the new size is greater than the original size, the extra paddign will be initialized with the value specified by the user.  <a href="#a883425a12e6bb517419e14b0e4a5b912"></a><br/></td></tr>
<tr class="separator:a883425a12e6bb517419e14b0e4a5b912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f330ecc24e2d13360a365fee5a7f29"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a63f330ecc24e2d13360a365fee5a7f29">size</a> (void) const </td></tr>
<tr class="memdesc:a63f330ecc24e2d13360a365fee5a7f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of known elements.  <a href="#a63f330ecc24e2d13360a365fee5a7f29"></a><br/></td></tr>
<tr class="separator:a63f330ecc24e2d13360a365fee5a7f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba1a4c6e1b00092cf5cc64645d903d6"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a4ba1a4c6e1b00092cf5cc64645d903d6">max_size</a> (void) const </td></tr>
<tr class="memdesc:a4ba1a4c6e1b00092cf5cc64645d903d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum number of elements possible to allocate on the associated device.  <a href="#a4ba1a4c6e1b00092cf5cc64645d903d6"></a><br/></td></tr>
<tr class="separator:a4ba1a4c6e1b00092cf5cc64645d903d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e72f412e1f3fa0c696be0f8da38c55d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a8e72f412e1f3fa0c696be0f8da38c55d">reserve</a> (size_type reqSize)</td></tr>
<tr class="memdesc:a8e72f412e1f3fa0c696be0f8da38c55d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request a change in the capacity of the <a class="el" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">device_vector</a>. If reserve completes successfully, this <a class="el" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">device_vector</a> object guarantees that the it can store the requested amount of elements without another reallocation, until the <a class="el" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">device_vector</a> size exceeds n.  <a href="#a8e72f412e1f3fa0c696be0f8da38c55d"></a><br/></td></tr>
<tr class="separator:a8e72f412e1f3fa0c696be0f8da38c55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d4b3785464f0a5dfca0c2adbd00593"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a49d4b3785464f0a5dfca0c2adbd00593">capacity</a> (void) const </td></tr>
<tr class="memdesc:a49d4b3785464f0a5dfca0c2adbd00593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum possible number of elements without reallocation.  <a href="#a49d4b3785464f0a5dfca0c2adbd00593"></a><br/></td></tr>
<tr class="separator:a49d4b3785464f0a5dfca0c2adbd00593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad55c36980fc8c1f8cae22877c53330f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#ad55c36980fc8c1f8cae22877c53330f3">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:ad55c36980fc8c1f8cae22877c53330f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shrink the <a class="el" href="classbolt_1_1cl_1_1device__vector.html#a49d4b3785464f0a5dfca0c2adbd00593" title="Return the maximum possible number of elements without reallocation.">capacity( )</a> of this <a class="el" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">device_vector</a> to just fit its elements. This makes the <a class="el" href="classbolt_1_1cl_1_1device__vector.html#a63f330ecc24e2d13360a365fee5a7f29" title="Return the number of known elements.">size( )</a> of the vector equal to its <a class="el" href="classbolt_1_1cl_1_1device__vector.html#a49d4b3785464f0a5dfca0c2adbd00593" title="Return the maximum possible number of elements without reallocation.">capacity( )</a>.  <a href="#ad55c36980fc8c1f8cae22877c53330f3"></a><br/></td></tr>
<tr class="separator:ad55c36980fc8c1f8cae22877c53330f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d58494857b26e9cc8bd00a720433ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a0845c082f9128d4e89ab30037103bcf2">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#aa9d58494857b26e9cc8bd00a720433ce">operator[]</a> (size_type n)</td></tr>
<tr class="memdesc:aa9d58494857b26e9cc8bd00a720433ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the value stored at index n.  <a href="#aa9d58494857b26e9cc8bd00a720433ce"></a><br/></td></tr>
<tr class="separator:aa9d58494857b26e9cc8bd00a720433ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a7da3709b0c02873cbff51eaa56b9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a2a53b6416da92e99626e64ff9eb97616">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a78a7da3709b0c02873cbff51eaa56b9f">operator[]</a> (size_type n) const </td></tr>
<tr class="memdesc:a78a7da3709b0c02873cbff51eaa56b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a constant value stored at index n.  <a href="#a78a7da3709b0c02873cbff51eaa56b9f"></a><br/></td></tr>
<tr class="separator:a78a7da3709b0c02873cbff51eaa56b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcfa66f58ba75564ab14482c5934ee87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#ad1c531350e4e69702b01b6e1cb22fecd">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#adcfa66f58ba75564ab14482c5934ee87">begin</a> (void)</td></tr>
<tr class="memdesc:adcfa66f58ba75564ab14482c5934ee87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves an iterator for this container that points at the beginning element.  <a href="#adcfa66f58ba75564ab14482c5934ee87"></a><br/></td></tr>
<tr class="separator:adcfa66f58ba75564ab14482c5934ee87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d32e4596e59a02475eb750c0b1f422b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#ad113d8217364ce718b6d1e012a4c378b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a1d32e4596e59a02475eb750c0b1f422b">begin</a> (void) const </td></tr>
<tr class="memdesc:a1d32e4596e59a02475eb750c0b1f422b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves an iterator for this container that points at the beginning constant element. No operation through this iterator may modify the contents of the referenced container.  <a href="#a1d32e4596e59a02475eb750c0b1f422b"></a><br/></td></tr>
<tr class="separator:a1d32e4596e59a02475eb750c0b1f422b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae09b56f6def3cd9e4698686bbee3aee0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#ad113d8217364ce718b6d1e012a4c378b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#ae09b56f6def3cd9e4698686bbee3aee0">cbegin</a> (void) const </td></tr>
<tr class="memdesc:ae09b56f6def3cd9e4698686bbee3aee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves an iterator for this container that points at the beginning constant element. No operation through this iterator may modify the contents of the referenced container.  <a href="#ae09b56f6def3cd9e4698686bbee3aee0"></a><br/></td></tr>
<tr class="separator:ae09b56f6def3cd9e4698686bbee3aee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52fb990547ceab966334c70824a526f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a1e424505b6f3d034429d6959f3b6b1a1">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#af52fb990547ceab966334c70824a526f">rbegin</a> (void)</td></tr>
<tr class="memdesc:af52fb990547ceab966334c70824a526f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a reverse_iterator for this container that points at the last element.  <a href="#af52fb990547ceab966334c70824a526f"></a><br/></td></tr>
<tr class="separator:af52fb990547ceab966334c70824a526f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ce0ca97d251f31880c4be19cfe57f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a15fb87576fc9597557aa65e6e15ac18e">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#aa0ce0ca97d251f31880c4be19cfe57f5">rbegin</a> (void) const </td></tr>
<tr class="memdesc:aa0ce0ca97d251f31880c4be19cfe57f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a reverse_iterator for this container that points at the last constant element. No operation through this iterator may modify the contents of the referenced container.  <a href="#aa0ce0ca97d251f31880c4be19cfe57f5"></a><br/></td></tr>
<tr class="separator:aa0ce0ca97d251f31880c4be19cfe57f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ba55a2bb0ab91d1ae91e66ea42053f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a15fb87576fc9597557aa65e6e15ac18e">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a45ba55a2bb0ab91d1ae91e66ea42053f">crbegin</a> (void) const </td></tr>
<tr class="memdesc:a45ba55a2bb0ab91d1ae91e66ea42053f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves an iterator for this container that points at the last constant element. No operation through this iterator may modify the contents of the referenced container.  <a href="#a45ba55a2bb0ab91d1ae91e66ea42053f"></a><br/></td></tr>
<tr class="separator:a45ba55a2bb0ab91d1ae91e66ea42053f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21179fdc21dd47292b865bd064975fd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#ad1c531350e4e69702b01b6e1cb22fecd">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a21179fdc21dd47292b865bd064975fd2">end</a> (void)</td></tr>
<tr class="memdesc:a21179fdc21dd47292b865bd064975fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves an iterator for this container that points at the last element.  <a href="#a21179fdc21dd47292b865bd064975fd2"></a><br/></td></tr>
<tr class="separator:a21179fdc21dd47292b865bd064975fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7551663ea83c860c7590e8dc208bf24b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#ad113d8217364ce718b6d1e012a4c378b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a7551663ea83c860c7590e8dc208bf24b">end</a> (void) const </td></tr>
<tr class="memdesc:a7551663ea83c860c7590e8dc208bf24b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves an iterator for this container that points at the last constant element. No operation through this iterator may modify the contents of the referenced container.  <a href="#a7551663ea83c860c7590e8dc208bf24b"></a><br/></td></tr>
<tr class="separator:a7551663ea83c860c7590e8dc208bf24b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac567628917b70c6d00da974c00b23ca0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#ad113d8217364ce718b6d1e012a4c378b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#ac567628917b70c6d00da974c00b23ca0">cend</a> (void) const </td></tr>
<tr class="memdesc:ac567628917b70c6d00da974c00b23ca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves an iterator for this container that points at the last constant element. No operation through this iterator may modify the contents of the referenced container.  <a href="#ac567628917b70c6d00da974c00b23ca0"></a><br/></td></tr>
<tr class="separator:ac567628917b70c6d00da974c00b23ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1d9effa92fa4b6500ec6272c50c631"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a1e424505b6f3d034429d6959f3b6b1a1">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a2a1d9effa92fa4b6500ec6272c50c631">rend</a> (void)</td></tr>
<tr class="memdesc:a2a1d9effa92fa4b6500ec6272c50c631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a reverse_iterator for this container that points at the beginning element.  <a href="#a2a1d9effa92fa4b6500ec6272c50c631"></a><br/></td></tr>
<tr class="separator:a2a1d9effa92fa4b6500ec6272c50c631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf94a2f369cc5d5a36495d92af856ca7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a15fb87576fc9597557aa65e6e15ac18e">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#aaf94a2f369cc5d5a36495d92af856ca7">rend</a> (void) const </td></tr>
<tr class="memdesc:aaf94a2f369cc5d5a36495d92af856ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a reverse_iterator for this container that points at the beginning constant element. No operation through this iterator may modify the contents of the referenced container.  <a href="#aaf94a2f369cc5d5a36495d92af856ca7"></a><br/></td></tr>
<tr class="separator:aaf94a2f369cc5d5a36495d92af856ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f08488d0d7c173a703dc9ae85e7c97f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a15fb87576fc9597557aa65e6e15ac18e">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a2f08488d0d7c173a703dc9ae85e7c97f">crend</a> (void) const </td></tr>
<tr class="memdesc:a2f08488d0d7c173a703dc9ae85e7c97f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a reverse_iterator for this container that points at the beginning constant element. No operation through this iterator may modify the contents of the referenced container.  <a href="#a2f08488d0d7c173a703dc9ae85e7c97f"></a><br/></td></tr>
<tr class="separator:a2f08488d0d7c173a703dc9ae85e7c97f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd76b33fa6f48589e3a03fb3fbe477d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a0845c082f9128d4e89ab30037103bcf2">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a9bd76b33fa6f48589e3a03fb3fbe477d">front</a> (void)</td></tr>
<tr class="memdesc:a9bd76b33fa6f48589e3a03fb3fbe477d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the value stored at index 0.  <a href="#a9bd76b33fa6f48589e3a03fb3fbe477d"></a><br/></td></tr>
<tr class="separator:a9bd76b33fa6f48589e3a03fb3fbe477d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa2fd5e6ce89e39327c0d59e9097fea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a2a53b6416da92e99626e64ff9eb97616">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#abfa2fd5e6ce89e39327c0d59e9097fea">front</a> (void) const </td></tr>
<tr class="memdesc:abfa2fd5e6ce89e39327c0d59e9097fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the value stored at index 0.  <a href="#abfa2fd5e6ce89e39327c0d59e9097fea"></a><br/></td></tr>
<tr class="separator:abfa2fd5e6ce89e39327c0d59e9097fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35339d472d9cbeabc2108c5c98151d5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a0845c082f9128d4e89ab30037103bcf2">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a35339d472d9cbeabc2108c5c98151d5d">back</a> (void)</td></tr>
<tr class="memdesc:a35339d472d9cbeabc2108c5c98151d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the value stored at index <a class="el" href="classbolt_1_1cl_1_1device__vector.html#a63f330ecc24e2d13360a365fee5a7f29" title="Return the number of known elements.">size( )</a> - 1.  <a href="#a35339d472d9cbeabc2108c5c98151d5d"></a><br/></td></tr>
<tr class="separator:a35339d472d9cbeabc2108c5c98151d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9166c3ed4cf32aa22ca7291b4298250c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a2a53b6416da92e99626e64ff9eb97616">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a9166c3ed4cf32aa22ca7291b4298250c">back</a> (void) const </td></tr>
<tr class="memdesc:a9166c3ed4cf32aa22ca7291b4298250c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the value stored at index <a class="el" href="classbolt_1_1cl_1_1device__vector.html#a63f330ecc24e2d13360a365fee5a7f29" title="Return the number of known elements.">size( )</a> - 1.  <a href="#a9166c3ed4cf32aa22ca7291b4298250c"></a><br/></td></tr>
<tr class="separator:a9166c3ed4cf32aa22ca7291b4298250c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53fa642df197102b704338210a78d860"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53fa642df197102b704338210a78d860"></a>
pointer&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> (void)</td></tr>
<tr class="separator:a53fa642df197102b704338210a78d860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0baafaa9f6ef3a664319e64e3d870e23"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0baafaa9f6ef3a664319e64e3d870e23"></a>
const_pointer&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> (void) const </td></tr>
<tr class="separator:a0baafaa9f6ef3a664319e64e3d870e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8613288b9ae768fc43476abda2dd0dee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a8613288b9ae768fc43476abda2dd0dee">clear</a> (void)</td></tr>
<tr class="memdesc:a8613288b9ae768fc43476abda2dd0dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements (makes the <a class="el" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">device_vector</a> empty).  <a href="#a8613288b9ae768fc43476abda2dd0dee"></a><br/></td></tr>
<tr class="separator:a8613288b9ae768fc43476abda2dd0dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840343c30b7e7ba96fb2b8d9908b680f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a840343c30b7e7ba96fb2b8d9908b680f">empty</a> (void) const </td></tr>
<tr class="memdesc:a840343c30b7e7ba96fb2b8d9908b680f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether the container is empty.  <a href="#a840343c30b7e7ba96fb2b8d9908b680f"></a><br/></td></tr>
<tr class="separator:a840343c30b7e7ba96fb2b8d9908b680f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab6838e3f3b6a179492fa6bc5c3d3cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a1ab6838e3f3b6a179492fa6bc5c3d3cc">push_back</a> (const value_type &amp;value)</td></tr>
<tr class="memdesc:a1ab6838e3f3b6a179492fa6bc5c3d3cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a copy of the value to the container.  <a href="#a1ab6838e3f3b6a179492fa6bc5c3d3cc"></a><br/></td></tr>
<tr class="separator:a1ab6838e3f3b6a179492fa6bc5c3d3cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ab6a7133d57fac614232c00fad6880"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6ab6a7133d57fac614232c00fad6880"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#aa6ab6a7133d57fac614232c00fad6880">pop_back</a> (void)</td></tr>
<tr class="memdesc:aa6ab6a7133d57fac614232c00fad6880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last element, but does not return it. <br/></td></tr>
<tr class="separator:aa6ab6a7133d57fac614232c00fad6880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde9c80244756dc0150c797c2f913fc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#afde9c80244756dc0150c797c2f913fc9">swap</a> (<a class="el" href="classbolt_1_1cl_1_1device__vector.html">device_vector</a> &amp;vec)</td></tr>
<tr class="memdesc:afde9c80244756dc0150c797c2f913fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of two device_vectors in an efficient manner.  <a href="#afde9c80244756dc0150c797c2f913fc9"></a><br/></td></tr>
<tr class="separator:afde9c80244756dc0150c797c2f913fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94615544ec541619e3d4777ff3eeb01c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#ad1c531350e4e69702b01b6e1cb22fecd">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a94615544ec541619e3d4777ff3eeb01c">erase</a> (<a class="el" href="classbolt_1_1cl_1_1device__vector.html#ad113d8217364ce718b6d1e012a4c378b">const_iterator</a> index)</td></tr>
<tr class="memdesc:a94615544ec541619e3d4777ff3eeb01c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an element.  <a href="#a94615544ec541619e3d4777ff3eeb01c"></a><br/></td></tr>
<tr class="separator:a94615544ec541619e3d4777ff3eeb01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b93fbcb1127080ed99b37cdb27d82d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#ad1c531350e4e69702b01b6e1cb22fecd">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a0b93fbcb1127080ed99b37cdb27d82d8">erase</a> (<a class="el" href="classbolt_1_1cl_1_1device__vector.html#ad113d8217364ce718b6d1e012a4c378b">const_iterator</a> first, <a class="el" href="classbolt_1_1cl_1_1device__vector.html#ad113d8217364ce718b6d1e012a4c378b">const_iterator</a> last)</td></tr>
<tr class="memdesc:a0b93fbcb1127080ed99b37cdb27d82d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a range of elements.  <a href="#a0b93fbcb1127080ed99b37cdb27d82d8"></a><br/></td></tr>
<tr class="separator:a0b93fbcb1127080ed99b37cdb27d82d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268b32f198ba17f70a93e1ab5add4ac2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#ad1c531350e4e69702b01b6e1cb22fecd">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a268b32f198ba17f70a93e1ab5add4ac2">insert</a> (<a class="el" href="classbolt_1_1cl_1_1device__vector.html#ad113d8217364ce718b6d1e012a4c378b">const_iterator</a> index, const value_type &amp;value)</td></tr>
<tr class="memdesc:a268b32f198ba17f70a93e1ab5add4ac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new element into the container.  <a href="#a268b32f198ba17f70a93e1ab5add4ac2"></a><br/></td></tr>
<tr class="separator:a268b32f198ba17f70a93e1ab5add4ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af18cf97598a1caf171d4180d842983dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#af18cf97598a1caf171d4180d842983dd">insert</a> (<a class="el" href="classbolt_1_1cl_1_1device__vector.html#ad113d8217364ce718b6d1e012a4c378b">const_iterator</a> index, size_type n, const value_type &amp;value)</td></tr>
<tr class="memdesc:af18cf97598a1caf171d4180d842983dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts n copies of the new element into the container.  <a href="#af18cf97598a1caf171d4180d842983dd"></a><br/></td></tr>
<tr class="separator:af18cf97598a1caf171d4180d842983dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c39394b2af479ae829b1589546a1ea5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1c39394b2af479ae829b1589546a1ea5"></a>
template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a1c39394b2af479ae829b1589546a1ea5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert</b> (<a class="el" href="classbolt_1_1cl_1_1device__vector.html#ad113d8217364ce718b6d1e012a4c378b">const_iterator</a> index, InputIterator <a class="el" href="classbolt_1_1cl_1_1device__vector.html#adcfa66f58ba75564ab14482c5934ee87">begin</a>, InputIterator <a class="el" href="classbolt_1_1cl_1_1device__vector.html#a21179fdc21dd47292b865bd064975fd2">end</a>)</td></tr>
<tr class="separator:a1c39394b2af479ae829b1589546a1ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad66deec46898302ffdc24eaebe2e494a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#ad66deec46898302ffdc24eaebe2e494a">assign</a> (size_type newSize, const value_type &amp;value)</td></tr>
<tr class="memdesc:ad66deec46898302ffdc24eaebe2e494a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns newSize copies of element value.  <a href="#ad66deec46898302ffdc24eaebe2e494a"></a><br/></td></tr>
<tr class="separator:ad66deec46898302ffdc24eaebe2e494a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18607635286a91515638a72efb9f950"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:ad18607635286a91515638a72efb9f950"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; !std::is_same<br class="typebreak"/>
&lt; typename <br class="typebreak"/>
std::iterator_traits<br class="typebreak"/>
&lt; InputIterator &gt;::value_type, <br class="typebreak"/>
typename size_type &gt;::value, <br class="typebreak"/>
void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#ad18607635286a91515638a72efb9f950">assign</a> (InputIterator <a class="el" href="classbolt_1_1cl_1_1device__vector.html#adcfa66f58ba75564ab14482c5934ee87">begin</a>, InputIterator <a class="el" href="classbolt_1_1cl_1_1device__vector.html#a21179fdc21dd47292b865bd064975fd2">end</a>)</td></tr>
<tr class="memdesc:ad18607635286a91515638a72efb9f950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a range of values to <a class="el" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">device_vector</a>, replacing all previous elements.  <a href="#ad18607635286a91515638a72efb9f950"></a><br/></td></tr>
<tr class="separator:ad18607635286a91515638a72efb9f950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be79cfe0c74aa4593f9164bc9526d75"><td class="memItemLeft" align="right" valign="top">const ::cl::Buffer &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a6be79cfe0c74aa4593f9164bc9526d75">getBuffer</a> () const </td></tr>
<tr class="memdesc:a6be79cfe0c74aa4593f9164bc9526d75"><td class="mdescLeft">&#160;</td><td class="mdescRight">A get accessor function to return the encapsulated device buffer for const objects. This member function allows access to the Buffer object, which can be retrieved through a reference or an iterator. This is necessary to allow library functions to set the encapsulated buffer object as a kernel argument.  <a href="#a6be79cfe0c74aa4593f9164bc9526d75"></a><br/></td></tr>
<tr class="separator:a6be79cfe0c74aa4593f9164bc9526d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8101620f824880a6d6eda4aeb2a6fdda"><td class="memItemLeft" align="right" valign="top">::cl::Buffer &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a8101620f824880a6d6eda4aeb2a6fdda">getBuffer</a> ()</td></tr>
<tr class="memdesc:a8101620f824880a6d6eda4aeb2a6fdda"><td class="mdescLeft">&#160;</td><td class="mdescRight">A get accessor function to return the encapsulated device buffer for non-const objects. This member function allows access to the Buffer object, which can be retrieved through a reference or an iterator. This is necessary to allow library functions to set the encapsulated buffer object as a kernel argument.  <a href="#a8101620f824880a6d6eda4aeb2a6fdda"></a><br/></td></tr>
<tr class="separator:a8101620f824880a6d6eda4aeb2a6fdda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a811ee22ffe70f7ebb2829f620f369cdb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a811ee22ffe70f7ebb2829f620f369cdb"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>
<tr class="separator:a811ee22ffe70f7ebb2829f620f369cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br/>
class bolt::cl::device_vector&lt; T &gt;</h3>

<p>This defines the OpenCL version of a <a class="el" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">device_vector</a>. </p>
<p>A <a class="el" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">device_vector</a> is an abstract data type that provides random access to a flat, sequential region of memory that is performant for the device. This can imply different memories for different devices. For discrete class graphics, devices, this is most likely video memory; for APU devices, this can imply zero-copy memory; for CPU devices, this can imply standard host memory. </p>
<dl class="section see"><dt>See Also</dt><dd><a href="http://www.sgi.com/tech/stl/Vector.html">http://www.sgi.com/tech/stl/Vector.html</a> </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a2a53b6416da92e99626e64ff9eb97616"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const value_type <a class="el" href="classbolt_1_1cl_1_1device__vector.html">bolt::cl::device_vector</a>&lt; T &gt;::<a class="el" href="classbolt_1_1cl_1_1device__vector.html#a2a53b6416da92e99626e64ff9eb97616">const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A non-writeable copy of an element of the container. Constant references are optimized to return a value_type, since it is certain that the value will not be modified. </p>
<dl class="section note"><dt>Note</dt><dd>A const_reference actually returns a value, not a reference. </dd></dl>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a01c1f40015e9b9f8699cf92c40cfa3a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbolt_1_1cl_1_1device__vector.html">bolt::cl::device_vector</a>&lt; T &gt;::<a class="el" href="classbolt_1_1cl_1_1device__vector.html">device_vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbolt_1_1cl_1_1control.html">control</a> &amp;&#160;</td>
          <td class="paramname"><em>ctl</em> = <code><a class="el" href="group__CL-control.html#ga59712ff5a77d3714f716d85938705289">control::getDefault</a>(&#160;)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A default constructor that creates an empty <a class="el" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">device_vector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctl</td><td>An Bolt control class used to perform copy operations; a default is used if not supplied by the user </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>Find a way to be able to unambiguously specify memory flags for this constructor, that is not confused with the size constructor below. </dd></dl>

</div>
</div>
<a class="anchor" id="a0c551cec5c2827064d8c193b6853044c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbolt_1_1cl_1_1device__vector.html">bolt::cl::device_vector</a>&lt; T &gt;::<a class="el" href="classbolt_1_1cl_1_1device__vector.html">device_vector</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>newSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em> = <code>value_type(&#160;)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_mem_flags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>CL_MEM_READ_WRITE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>init</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbolt_1_1cl_1_1control.html">control</a> &amp;&#160;</td>
          <td class="paramname"><em>ctl</em> = <code><a class="el" href="group__CL-control.html#ga59712ff5a77d3714f716d85938705289">control::getDefault</a>(&#160;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A constructor that creates a new <a class="el" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">device_vector</a> with the specified number of elements, with a specified initial value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSize</td><td>The number of elements of the new <a class="el" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">device_vector</a> </td></tr>
    <tr><td class="paramname">value</td><td>The value with which to initialize new elements. </td></tr>
    <tr><td class="paramname">flags</td><td>A bitfield that takes the OpenCL memory flags to help specify where the <a class="el" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">device_vector</a> allocates memory. </td></tr>
    <tr><td class="paramname">init</td><td>Boolean value to indicate whether to initialize device memory from host memory. </td></tr>
    <tr><td class="paramname">ctl</td><td>A Bolt control class for copy operations; a default is used if not supplied by the user. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The ::cl::CommandQueue is not an STD <a class="el" href="classbolt_1_1cl_1_1device__vector.html#a8e72f412e1f3fa0c696be0f8da38c55d" title="Request a change in the capacity of the device_vector. If reserve completes successfully, this device_vector object guarantees that the it can store the requested amount of elements without another reallocation, until the device_vector size exceeds n.">reserve( )</a> parameter. </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000005">Bug:</a></b></dt><dd>The size of the value must be a power of two. Refer section 5.2.3 in 'The OpenCL 1.2 Specification' (Khronos) </dd></dl>

</div>
</div>
<a class="anchor" id="a1f808e7079196f70ec996eac9a014ae1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbolt_1_1cl_1_1device__vector.html">bolt::cl::device_vector</a>&lt; T &gt;::<a class="el" href="classbolt_1_1cl_1_1device__vector.html">device_vector</a> </td>
          <td>(</td>
          <td class="paramtype">const InputIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>newSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_mem_flags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>CL_MEM_READ_WRITE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>init</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbolt_1_1cl_1_1control.html">control</a> &amp;&#160;</td>
          <td class="paramname"><em>ctl</em> = <code><a class="el" href="group__CL-control.html#ga59712ff5a77d3714f716d85938705289">control::getDefault</a>(&#160;)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; !std::is_integral&lt; InputIterator &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A constructor that creates a new <a class="el" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">device_vector</a> using a range specified by the user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>An iterator pointing at the beginning of the range. </td></tr>
    <tr><td class="paramname">end</td><td>An iterator pointing at the end of the range. </td></tr>
    <tr><td class="paramname">flags</td><td>A bitfield that takes the OpenCL memory flags to help specify where the <a class="el" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">device_vector</a> allocates memory. </td></tr>
    <tr><td class="paramname">init</td><td>Boolean value to indicate whether to initialize device memory from host memory. </td></tr>
    <tr><td class="paramname">ctl</td><td>A Bolt control class used to perform copy operations; a default is used if not supplied by the user. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Ignore the enable_if&lt;&gt; parameter; it prevents this constructor from being called with integral types. </dd></dl>

</div>
</div>
<a class="anchor" id="adcb6977424f13ec0758b2c74f6b637c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbolt_1_1cl_1_1device__vector.html">bolt::cl::device_vector</a>&lt; T &gt;::<a class="el" href="classbolt_1_1cl_1_1device__vector.html">device_vector</a> </td>
          <td>(</td>
          <td class="paramtype">const InputIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_mem_flags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>CL_MEM_READ_WRITE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbolt_1_1cl_1_1control.html">control</a> &amp;&#160;</td>
          <td class="paramname"><em>ctl</em> = <code><a class="el" href="group__CL-control.html#ga59712ff5a77d3714f716d85938705289">control::getDefault</a>(&#160;)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; !std::is_integral&lt; InputIterator &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A constructor that creates a new <a class="el" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">device_vector</a> using a range specified by the user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>An iterator pointing at the beginning of the range. </td></tr>
    <tr><td class="paramname">end</td><td>An iterator pointing at the end of the range. </td></tr>
    <tr><td class="paramname">flags</td><td>A bitfield that takes the OpenCL memory flags to help specify where the <a class="el" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">device_vector</a> allocates memory. </td></tr>
    <tr><td class="paramname">ctl</td><td>A Bolt control class for copy operations; a default is used if not supplied by the user. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Ignore the enable_if&lt;&gt; parameter; it prevents this constructor from being called with integral types. </dd></dl>

</div>
</div>
<a class="anchor" id="acba05b856ae25b393d0b781cac71599b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbolt_1_1cl_1_1device__vector.html">bolt::cl::device_vector</a>&lt; T &gt;::<a class="el" href="classbolt_1_1cl_1_1device__vector.html">device_vector</a> </td>
          <td>(</td>
          <td class="paramtype">const ::cl::Buffer &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbolt_1_1cl_1_1control.html">control</a> &amp;&#160;</td>
          <td class="paramname"><em>ctl</em> = <code><a class="el" href="group__CL-control.html#ga59712ff5a77d3714f716d85938705289">control::getDefault</a>(&#160;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A constructor that creates a new <a class="el" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">device_vector</a> using a pre-initialized buffer supplied by the user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>A pre-existing ::cl::Buffer supplied by the user. </td></tr>
    <tr><td class="paramname">ctl</td><td>A Bolt control class for copy operations; a default is used if not supplied by the user. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad66deec46898302ffdc24eaebe2e494a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbolt_1_1cl_1_1device__vector.html">bolt::cl::device_vector</a>&lt; T &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>newSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns newSize copies of element value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSize</td><td>The new size of the <a class="el" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">device_vector</a>. </td></tr>
    <tr><td class="paramname">value</td><td>The value of the element that is replicated newSize times. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>All previous iterators, references, and pointers are invalidated. </dd></dl>

</div>
</div>
<a class="anchor" id="ad18607635286a91515638a72efb9f950"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; !std::is_same&lt; typename std::iterator_traits&lt;InputIterator &gt;::value_type, typename size_type &gt;::value, void&gt;::type <a class="el" href="classbolt_1_1cl_1_1device__vector.html">bolt::cl::device_vector</a>&lt; T &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns a range of values to <a class="el" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">device_vector</a>, replacing all previous elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>The iterator position signifiying the beginning of the range. </td></tr>
    <tr><td class="paramname">end</td><td>The iterator position signifying the end of the range (exclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>All previous iterators, references, and pointers are invalidated. </dd></dl>

</div>
</div>
<a class="anchor" id="a35339d472d9cbeabc2108c5c98151d5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a0845c082f9128d4e89ab30037103bcf2">reference</a> <a class="el" href="classbolt_1_1cl_1_1device__vector.html">bolt::cl::device_vector</a>&lt; T &gt;::back </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the value stored at index <a class="el" href="classbolt_1_1cl_1_1device__vector.html#a63f330ecc24e2d13360a365fee5a7f29" title="Return the number of known elements.">size( )</a> - 1. </p>
<dl class="section note"><dt>Note</dt><dd>This returns a proxy object, to control when device memory gets mapped. </dd></dl>

</div>
</div>
<a class="anchor" id="a9166c3ed4cf32aa22ca7291b4298250c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a2a53b6416da92e99626e64ff9eb97616">const_reference</a> <a class="el" href="classbolt_1_1cl_1_1device__vector.html">bolt::cl::device_vector</a>&lt; T &gt;::back </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the value stored at index <a class="el" href="classbolt_1_1cl_1_1device__vector.html#a63f330ecc24e2d13360a365fee5a7f29" title="Return the number of known elements.">size( )</a> - 1. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a const_reference, which is not a proxy object. </dd></dl>

</div>
</div>
<a class="anchor" id="adcfa66f58ba75564ab14482c5934ee87"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#ad1c531350e4e69702b01b6e1cb22fecd">iterator</a> <a class="el" href="classbolt_1_1cl_1_1device__vector.html">bolt::cl::device_vector</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves an iterator for this container that points at the beginning element. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classbolt_1_1cl_1_1device__vector.html#ad1c531350e4e69702b01b6e1cb22fecd" title="Typedef to create the non-constant iterator.">device_vector&lt; value_type &gt;::iterator</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a1d32e4596e59a02475eb750c0b1f422b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#ad113d8217364ce718b6d1e012a4c378b">const_iterator</a> <a class="el" href="classbolt_1_1cl_1_1device__vector.html">bolt::cl::device_vector</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves an iterator for this container that points at the beginning constant element. No operation through this iterator may modify the contents of the referenced container. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classbolt_1_1cl_1_1device__vector.html#ad113d8217364ce718b6d1e012a4c378b" title="Typedef to create the constant iterator.">device_vector&lt; value_type &gt;::const_iterator</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a49d4b3785464f0a5dfca0c2adbd00593"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbolt_1_1cl_1_1device__vector.html">bolt::cl::device_vector</a>&lt; T &gt;::capacity </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the maximum possible number of elements without reallocation. </p>
<dl class="section note"><dt>Note</dt><dd>Capacity() differs from <a class="el" href="classbolt_1_1cl_1_1device__vector.html#a63f330ecc24e2d13360a365fee5a7f29" title="Return the number of known elements.">size()</a>, in that <a class="el" href="classbolt_1_1cl_1_1device__vector.html#a49d4b3785464f0a5dfca0c2adbd00593" title="Return the maximum possible number of elements without reallocation.">capacity()</a> returns the number of elements that <b>could</b> be stored in the memory currently allocated. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the memory held by <a class="el" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">device_vector</a>, counted in elements. </dd></dl>

</div>
</div>
<a class="anchor" id="ae09b56f6def3cd9e4698686bbee3aee0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#ad113d8217364ce718b6d1e012a4c378b">const_iterator</a> <a class="el" href="classbolt_1_1cl_1_1device__vector.html">bolt::cl::device_vector</a>&lt; T &gt;::cbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves an iterator for this container that points at the beginning constant element. No operation through this iterator may modify the contents of the referenced container. </p>
<dl class="section note"><dt>Note</dt><dd>This method may return a constant iterator from a non-constant container. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classbolt_1_1cl_1_1device__vector.html#ad113d8217364ce718b6d1e012a4c378b" title="Typedef to create the constant iterator.">device_vector&lt; value_type &gt;::const_iterator</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ac567628917b70c6d00da974c00b23ca0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#ad113d8217364ce718b6d1e012a4c378b">const_iterator</a> <a class="el" href="classbolt_1_1cl_1_1device__vector.html">bolt::cl::device_vector</a>&lt; T &gt;::cend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves an iterator for this container that points at the last constant element. No operation through this iterator may modify the contents of the referenced container. </p>
<dl class="section note"><dt>Note</dt><dd>This method may return a constant iterator from a non-constant container. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classbolt_1_1cl_1_1device__vector.html#ad113d8217364ce718b6d1e012a4c378b" title="Typedef to create the constant iterator.">device_vector&lt; value_type &gt;::const_iterator</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a8613288b9ae768fc43476abda2dd0dee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbolt_1_1cl_1_1device__vector.html">bolt::cl::device_vector</a>&lt; T &gt;::clear </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all elements (makes the <a class="el" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">device_vector</a> empty). </p>
<dl class="section note"><dt>Note</dt><dd>All previous iterators, references and pointers are invalidated. </dd></dl>

</div>
</div>
<a class="anchor" id="a45ba55a2bb0ab91d1ae91e66ea42053f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a15fb87576fc9597557aa65e6e15ac18e">const_reverse_iterator</a> <a class="el" href="classbolt_1_1cl_1_1device__vector.html">bolt::cl::device_vector</a>&lt; T &gt;::crbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves an iterator for this container that points at the last constant element. No operation through this iterator may modify the contents of the referenced container. </p>
<dl class="section note"><dt>Note</dt><dd>This method may return a constant iterator from a non-constant container. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classbolt_1_1cl_1_1device__vector.html#a15fb87576fc9597557aa65e6e15ac18e" title="Typedef to create the constant reverse iterator.">device_vector&lt; value_type &gt;::const_reverse_iterator</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a2f08488d0d7c173a703dc9ae85e7c97f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a15fb87576fc9597557aa65e6e15ac18e">const_reverse_iterator</a> <a class="el" href="classbolt_1_1cl_1_1device__vector.html">bolt::cl::device_vector</a>&lt; T &gt;::crend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a reverse_iterator for this container that points at the beginning constant element. No operation through this iterator may modify the contents of the referenced container. </p>
<dl class="section note"><dt>Note</dt><dd>This method may return a constant iterator from a non-constant container. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classbolt_1_1cl_1_1device__vector.html#a15fb87576fc9597557aa65e6e15ac18e" title="Typedef to create the constant reverse iterator.">device_vector&lt; value_type &gt;::const_reverse_iterator</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a840343c30b7e7ba96fb2b8d9908b680f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbolt_1_1cl_1_1device__vector.html">bolt::cl::device_vector</a>&lt; T &gt;::empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test whether the container is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if <a class="el" href="classbolt_1_1cl_1_1device__vector.html#a63f330ecc24e2d13360a365fee5a7f29" title="Return the number of known elements.">size( )</a> == 0 </dd></dl>

</div>
</div>
<a class="anchor" id="a21179fdc21dd47292b865bd064975fd2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#ad1c531350e4e69702b01b6e1cb22fecd">iterator</a> <a class="el" href="classbolt_1_1cl_1_1device__vector.html">bolt::cl::device_vector</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves an iterator for this container that points at the last element. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classbolt_1_1cl_1_1device__vector.html#ad1c531350e4e69702b01b6e1cb22fecd" title="Typedef to create the non-constant iterator.">device_vector&lt; value_type &gt;::iterator</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a7551663ea83c860c7590e8dc208bf24b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#ad113d8217364ce718b6d1e012a4c378b">const_iterator</a> <a class="el" href="classbolt_1_1cl_1_1device__vector.html">bolt::cl::device_vector</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves an iterator for this container that points at the last constant element. No operation through this iterator may modify the contents of the referenced container. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classbolt_1_1cl_1_1device__vector.html#ad113d8217364ce718b6d1e012a4c378b" title="Typedef to create the constant iterator.">device_vector&lt; value_type &gt;::const_iterator</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a94615544ec541619e3d4777ff3eeb01c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#ad1c531350e4e69702b01b6e1cb22fecd">iterator</a> <a class="el" href="classbolt_1_1cl_1_1device__vector.html">bolt::cl::device_vector</a>&lt; T &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#ad113d8217364ce718b6d1e012a4c378b">const_iterator</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes an element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The iterator position in which to remove the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator position after the deleted element. </dd></dl>

</div>
</div>
<a class="anchor" id="a0b93fbcb1127080ed99b37cdb27d82d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#ad1c531350e4e69702b01b6e1cb22fecd">iterator</a> <a class="el" href="classbolt_1_1cl_1_1device__vector.html">bolt::cl::device_vector</a>&lt; T &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#ad113d8217364ce718b6d1e012a4c378b">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#ad113d8217364ce718b6d1e012a4c378b">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a range of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>The iterator position signifiying the beginning of the range. </td></tr>
    <tr><td class="paramname">end</td><td>The iterator position signifying the end of the range (exclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator position after the deleted range. </dd></dl>

</div>
</div>
<a class="anchor" id="a9bd76b33fa6f48589e3a03fb3fbe477d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a0845c082f9128d4e89ab30037103bcf2">reference</a> <a class="el" href="classbolt_1_1cl_1_1device__vector.html">bolt::cl::device_vector</a>&lt; T &gt;::front </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the value stored at index 0. </p>
<dl class="section note"><dt>Note</dt><dd>This returns a proxy object, to control when device memory gets mapped. </dd></dl>

</div>
</div>
<a class="anchor" id="abfa2fd5e6ce89e39327c0d59e9097fea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a2a53b6416da92e99626e64ff9eb97616">const_reference</a> <a class="el" href="classbolt_1_1cl_1_1device__vector.html">bolt::cl::device_vector</a>&lt; T &gt;::front </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the value stored at index 0. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a const_reference, which is not a proxy object. </dd></dl>

</div>
</div>
<a class="anchor" id="a6be79cfe0c74aa4593f9164bc9526d75"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ::cl::Buffer&amp; <a class="el" href="classbolt_1_1cl_1_1device__vector.html">bolt::cl::device_vector</a>&lt; T &gt;::getBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A get accessor function to return the encapsulated device buffer for const objects. This member function allows access to the Buffer object, which can be retrieved through a reference or an iterator. This is necessary to allow library functions to set the encapsulated buffer object as a kernel argument. </p>
<dl class="section note"><dt>Note</dt><dd>This get function could be implemented in the iterator, but the reference object is usually a temporary rvalue, so this location seems less intrusive to the design of the vector class. </dd></dl>

</div>
</div>
<a class="anchor" id="a8101620f824880a6d6eda4aeb2a6fdda"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">::cl::Buffer&amp; <a class="el" href="classbolt_1_1cl_1_1device__vector.html">bolt::cl::device_vector</a>&lt; T &gt;::getBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A get accessor function to return the encapsulated device buffer for non-const objects. This member function allows access to the Buffer object, which can be retrieved through a reference or an iterator. This is necessary to allow library functions to set the encapsulated buffer object as a kernel argument. </p>
<dl class="section note"><dt>Note</dt><dd>This get function can be implemented in the iterator, but the reference object is usually a temporary rvalue, so this location seems less intrusive to the design of the vector class. </dd></dl>

</div>
</div>
<a class="anchor" id="a268b32f198ba17f70a93e1ab5add4ac2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#ad1c531350e4e69702b01b6e1cb22fecd">iterator</a> <a class="el" href="classbolt_1_1cl_1_1device__vector.html">bolt::cl::device_vector</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#ad113d8217364ce718b6d1e012a4c378b">const_iterator</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a new element into the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The iterator position to insert a copy of the element. </td></tr>
    <tr><td class="paramname">value</td><td>The element to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The position of the new element. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only iterators before the insertion point remain valid after the insertion. </dd>
<dd>
If the container must grow to contain the new value, all iterators and references are invalidated. </dd></dl>

</div>
</div>
<a class="anchor" id="af18cf97598a1caf171d4180d842983dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbolt_1_1cl_1_1device__vector.html">bolt::cl::device_vector</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#ad113d8217364ce718b6d1e012a4c378b">const_iterator</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts n copies of the new element into the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The iterator position to insert n copies of the element. </td></tr>
    <tr><td class="paramname">n</td><td>The number of copies of element. </td></tr>
    <tr><td class="paramname">value</td><td>The element to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Only iterators before the insertion point remain valid after the insertion. </dd>
<dd>
If the container must grow to contain the new value, all iterators and references are invalidated. </dd></dl>

</div>
</div>
<a class="anchor" id="a4ba1a4c6e1b00092cf5cc64645d903d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbolt_1_1cl_1_1device__vector.html">bolt::cl::device_vector</a>&lt; T &gt;::max_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the maximum number of elements possible to allocate on the associated device. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum amount of memory possible to allocate, counted in elements. </dd></dl>

</div>
</div>
<a class="anchor" id="aa9d58494857b26e9cc8bd00a720433ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a0845c082f9128d4e89ab30037103bcf2">reference</a> <a class="el" href="classbolt_1_1cl_1_1device__vector.html">bolt::cl::device_vector</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the value stored at index n. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a proxy reference object, to control when device memory gets mapped. </dd></dl>

</div>
</div>
<a class="anchor" id="a78a7da3709b0c02873cbff51eaa56b9f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a2a53b6416da92e99626e64ff9eb97616">const_reference</a> <a class="el" href="classbolt_1_1cl_1_1device__vector.html">bolt::cl::device_vector</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a constant value stored at index n. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a const_reference, which is not a proxy object. </dd></dl>

</div>
</div>
<a class="anchor" id="a1ab6838e3f3b6a179492fa6bc5c3d3cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbolt_1_1cl_1_1device__vector.html">bolt::cl::device_vector</a>&lt; T &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a copy of the value to the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The element to append </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af52fb990547ceab966334c70824a526f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a1e424505b6f3d034429d6959f3b6b1a1">reverse_iterator</a> <a class="el" href="classbolt_1_1cl_1_1device__vector.html">bolt::cl::device_vector</a>&lt; T &gt;::rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a reverse_iterator for this container that points at the last element. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classbolt_1_1cl_1_1device__vector.html#a1e424505b6f3d034429d6959f3b6b1a1" title="Typedef to create the non-constant reverse iterator.">device_vector&lt; value_type &gt;::reverse_iterator</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="aa0ce0ca97d251f31880c4be19cfe57f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a15fb87576fc9597557aa65e6e15ac18e">const_reverse_iterator</a> <a class="el" href="classbolt_1_1cl_1_1device__vector.html">bolt::cl::device_vector</a>&lt; T &gt;::rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a reverse_iterator for this container that points at the last constant element. No operation through this iterator may modify the contents of the referenced container. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classbolt_1_1cl_1_1device__vector.html#a15fb87576fc9597557aa65e6e15ac18e" title="Typedef to create the constant reverse iterator.">device_vector&lt; value_type &gt;::const_reverse_iterator</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2a1d9effa92fa4b6500ec6272c50c631"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a1e424505b6f3d034429d6959f3b6b1a1">reverse_iterator</a> <a class="el" href="classbolt_1_1cl_1_1device__vector.html">bolt::cl::device_vector</a>&lt; T &gt;::rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a reverse_iterator for this container that points at the beginning element. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classbolt_1_1cl_1_1device__vector.html#a1e424505b6f3d034429d6959f3b6b1a1" title="Typedef to create the non-constant reverse iterator.">device_vector&lt; value_type &gt;::reverse_iterator</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="aaf94a2f369cc5d5a36495d92af856ca7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a15fb87576fc9597557aa65e6e15ac18e">const_reverse_iterator</a> <a class="el" href="classbolt_1_1cl_1_1device__vector.html">bolt::cl::device_vector</a>&lt; T &gt;::rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a reverse_iterator for this container that points at the beginning constant element. No operation through this iterator may modify the contents of the referenced container. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classbolt_1_1cl_1_1device__vector.html#a15fb87576fc9597557aa65e6e15ac18e" title="Typedef to create the constant reverse iterator.">device_vector&lt; value_type &gt;::const_reverse_iterator</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a8e72f412e1f3fa0c696be0f8da38c55d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbolt_1_1cl_1_1device__vector.html">bolt::cl::device_vector</a>&lt; T &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>reqSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request a change in the capacity of the <a class="el" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">device_vector</a>. If reserve completes successfully, this <a class="el" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">device_vector</a> object guarantees that the it can store the requested amount of elements without another reallocation, until the <a class="el" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">device_vector</a> size exceeds n. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The requested size of the <a class="el" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">device_vector</a> in elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a49d4b3785464f0a5dfca0c2adbd00593" title="Return the maximum possible number of elements without reallocation.">capacity( )</a> may exceed n, but will not be less than n. </dd>
<dd>
Contents are preserved, and the <a class="el" href="classbolt_1_1cl_1_1device__vector.html#a63f330ecc24e2d13360a365fee5a7f29" title="Return the number of known elements.">size( )</a> of the vector is not affected. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>if the <a class="el" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">device_vector</a> must reallocate, all previous iterators, references, and pointers are invalidated. </dd>
<dd>
The ::cl::CommandQueue is not a STD <a class="el" href="classbolt_1_1cl_1_1device__vector.html#a8e72f412e1f3fa0c696be0f8da38c55d" title="Request a change in the capacity of the device_vector. If reserve completes successfully, this device_vector object guarantees that the it can store the requested amount of elements without another reallocation, until the device_vector size exceeds n.">reserve( )</a> parameter </dd></dl>

</div>
</div>
<a class="anchor" id="a883425a12e6bb517419e14b0e4a5b912"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbolt_1_1cl_1_1device__vector.html">bolt::cl::device_vector</a>&lt; T &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>reqSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>val</em> = <code>value_type(&#160;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the number of elements in <a class="el" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">device_vector</a> to reqSize. If the new requested size is less than the original size, the data is truncated and lost. If the new size is greater than the original size, the extra paddign will be initialized with the value specified by the user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reqSize</td><td>The requested size of the <a class="el" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">device_vector</a> in elements. </td></tr>
    <tr><td class="paramname">val</td><td>All new elements are initialized with this new value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a49d4b3785464f0a5dfca0c2adbd00593" title="Return the maximum possible number of elements without reallocation.">capacity( )</a> may exceed n, but is not less than n. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If the <a class="el" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">device_vector</a> must reallocate, all previous iterators, references, and pointers are invalidated. </dd>
<dd>
The ::cl::CommandQueue is not a STD <a class="el" href="classbolt_1_1cl_1_1device__vector.html#a8e72f412e1f3fa0c696be0f8da38c55d" title="Request a change in the capacity of the device_vector. If reserve completes successfully, this device_vector object guarantees that the it can store the requested amount of elements without another reallocation, until the device_vector size exceeds n.">reserve( )</a> parameter </dd></dl>

</div>
</div>
<a class="anchor" id="ad55c36980fc8c1f8cae22877c53330f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbolt_1_1cl_1_1device__vector.html">bolt::cl::device_vector</a>&lt; T &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shrink the <a class="el" href="classbolt_1_1cl_1_1device__vector.html#a49d4b3785464f0a5dfca0c2adbd00593" title="Return the maximum possible number of elements without reallocation.">capacity( )</a> of this <a class="el" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">device_vector</a> to just fit its elements. This makes the <a class="el" href="classbolt_1_1cl_1_1device__vector.html#a63f330ecc24e2d13360a365fee5a7f29" title="Return the number of known elements.">size( )</a> of the vector equal to its <a class="el" href="classbolt_1_1cl_1_1device__vector.html#a49d4b3785464f0a5dfca0c2adbd00593" title="Return the maximum possible number of elements without reallocation.">capacity( )</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Contents are preserved. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>if the <a class="el" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">device_vector</a> must reallocate, all previous iterators, references, and pointers are invalidated. </dd>
<dd>
The ::cl::CommandQueue is not a STD <a class="el" href="classbolt_1_1cl_1_1device__vector.html#a8e72f412e1f3fa0c696be0f8da38c55d" title="Request a change in the capacity of the device_vector. If reserve completes successfully, this device_vector object guarantees that the it can store the requested amount of elements without another reallocation, until the device_vector size exceeds n.">reserve( )</a> parameter. </dd></dl>

</div>
</div>
<a class="anchor" id="a63f330ecc24e2d13360a365fee5a7f29"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbolt_1_1cl_1_1device__vector.html">bolt::cl::device_vector</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of known elements. </p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classbolt_1_1cl_1_1device__vector.html#a63f330ecc24e2d13360a365fee5a7f29" title="Return the number of known elements.">size( )</a> differs from <a class="el" href="classbolt_1_1cl_1_1device__vector.html#a49d4b3785464f0a5dfca0c2adbd00593" title="Return the maximum possible number of elements without reallocation.">capacity( )</a>, in that <a class="el" href="classbolt_1_1cl_1_1device__vector.html#a63f330ecc24e2d13360a365fee5a7f29" title="Return the number of known elements.">size( )</a> returns the number of elements between <a class="el" href="classbolt_1_1cl_1_1device__vector.html#adcfa66f58ba75564ab14482c5934ee87" title="Retrieves an iterator for this container that points at the beginning element.">begin()</a> &amp; <a class="el" href="classbolt_1_1cl_1_1device__vector.html#a21179fdc21dd47292b865bd064975fd2" title="Retrieves an iterator for this container that points at the last element.">end()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Number of valid elements </dd></dl>

</div>
</div>
<a class="anchor" id="afde9c80244756dc0150c797c2f913fc9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbolt_1_1cl_1_1device__vector.html">bolt::cl::device_vector</a>&lt; T &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbolt_1_1cl_1_1device__vector.html">device_vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of two device_vectors in an efficient manner. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The <a class="el" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">device_vector</a> to swap with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Avinash_Bolt/Bolt_forked/Bolt/include/bolt/cl/<a class="el" href="cl_2device__vector_8h_source.html">device_vector.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jun 25 2013 12:42:23 for Bolt by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3
</small></address>
</body>
</html>
