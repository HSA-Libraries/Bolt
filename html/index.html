<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>Bolt: Bolt Documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Bolt
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">C++ template library with support for OpenCL</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Bolt Documentation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#intro_sec">Introduction</a></li>
<li class="level1"><a href="#example_sec">Examples</a><ul><li class="level2"><a href="#simplexample_sec">Simple Example</a></li>
<li class="level2"><a href="#subexample_sec">Bolt Functor Example</a></li>
<li class="level2"><a href="#subexample2_sec">Templatized Bolt Functor</a></li>
</ul>
</li>
<li class="level1"><a href="#Function_Path">Supported Functions and Code Paths</a><ul><li class="level2"><a href="#paths">Code Path Behaviour</a><ul><li class="level3"><a href="#Default">Default Behaviour</a></li>
<li class="level3"><a href="#Force">Force Behaviour</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#Requirements">Requirements</a></li>
</ul>
</div>
<div class="textblock"><div class="image">
<img src="bolt.png" alt="bolt.png"/>
</div>
<h1><a class="anchor" id="intro_sec"></a>
Introduction</h1>
<p>Bolt is a C++ template library optimized for GPUs. Bolt is designed to provide high-performance library implementations for common algorithms such as scan, reduce, transform, and sort. The Bolt interface was modeled on the C++ Standard Template Library (STL). Developers familiar with STL will recognize many of the Bolt APIs and customization techniques.</p>
<p>C++ templates can be used to customize the algorithms with new types (for example, the Bolt <code>sort</code> can operate on ints, float, or any custom type defined by the user). Additionally, Bolt lets users customize the template routines using function objects (functors) written in OpenCL &trade; for example, to provide a custom comparison operation for <code>sort</code>, or a custom reduction operation.</p>
<p>Bolt can directly interface with host memory structures such as <code>std::vector</code> or host arrays (e.g. <code>float*</code>). On today's GPU systems, the host memory is mapped or copied automatically to the GPU. On future systems that support the Heterogeneous System Architecture, the GPU will directly access the host data structures. Bolt also provides a <a class="el" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">bolt::cl::device_vector</a> that can be used to allocate and manage device-local memory for higher performance on discrete GPU systems. Bolt APIs can accept either host memory or the device vector.</p>
<p>This document introduces the architecture of Bolt and also provides a reference for the Bolt APIs.</p>
<h1><a class="anchor" id="example_sec"></a>
Examples</h1>
<h2><a class="anchor" id="simplexample_sec"></a>
Simple Example</h2>
<p>The simple example below shows how to use Bolt to sort a random array of 8192 integers. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cl_2sort_8h.html" title="Returns the sorted result of all the elements in input.">bolt/cl/sort.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// generate random data (on host)</span></div>
<div class="line">    std::vector&lt;int&gt; a(8192);</div>
<div class="line">    <a class="code" href="group__CL-filling.html#gaab817673f478a5e719a3b960e9dad4ea" title="generate assigns to each element of a sequence [first,last] the value returned by gen...">std::generate</a>(a.begin(), a.end(), rand);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// sort, run on best device in the platform</span></div>
<div class="line">    <a class="code" href="group__CL-sort.html#ga7720660d4a8dee06ea5314d3a1db7db3" title="This version of sort returns the sorted result of all the elements in the RandomAccessIterator betwee...">bolt::cl::sort</a>(a.begin(), a.end());</div>
<div class="line">}</div>
</div><!-- fragment --><p>The code will be familiar to the programmers who have used the C++ Standard Template Library; the difference is the include file (<a class="el" href="cl_2sort_8h.html" title="Returns the sorted result of all the elements in input.">bolt/cl/sort.h</a>) and the <code><a class="el" href="namespacebolt_1_1cl.html" title="Namespace containing OpenCL related data types and functions.">bolt::cl</a></code> namespace before the <code>sort</code> call. Bolt developers do not need to learn a new device-specific programming model to leverage the power and performance advantages of GPU computing.</p>
<p>The example demonstrates two important features of Bolt: </p>
<ul>
<li>The host-allocated vector "a" is directly passed to the Bolt <code>sort</code> routine, without a need to explicitly allocate and manage GPU device memory. </li>
<li>The Bolt <code><a class="el" href="group__CL-sort.html#ga7720660d4a8dee06ea5314d3a1db7db3" title="This version of sort returns the sorted result of all the elements in the RandomAccessIterator betwee...">bolt::cl::sort</a></code> call submits to the platform, rather than a specific device. The Bolt runtime selects the best device to run the sort, potentially running it on the CPU in the event a GPU is not available or the sort size is too small to benefit from GPU acceleration.</li>
</ul>
<h2><a class="anchor" id="subexample_sec"></a>
Bolt Functor Example</h2>
<p>Below example shows how to use Functors with BOLT. For user defined datatypes to work with BOLT functor, user has to wrap his data type around a macro BOLT_FUNCTOR. This enables the user defined class to be available as a string to the OpenCL Compiler which is invoked during a call to clBuildProgram(). Consider the following example. </p>
<div class="fragment"><div class="line"><a class="code" href="group__ClCode.html#ga2478d544fdd6b2cb0b1104ee5378a177">BOLT_FUNCTOR</a>(MyType&lt;int&gt;,</div>
<div class="line">template &lt;typename T&gt;</div>
<div class="line"><span class="keyword">struct</span> MyType {</div>
<div class="line">    T a;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> operator() (<span class="keyword">const</span> MyType&amp; lhs, <span class="keyword">const</span> MyType&amp; rhs)<span class="keyword"> const  </span>{</div>
<div class="line">        <span class="keywordflow">return</span> (lhs.a &gt; rhs.a);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">bool</span> <a class="code" href="group__pair.html#gafd150c808efd3e9205b069bf3f62f3ea">operator &lt; </a>(<span class="keyword">const</span> MyType&amp; other)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> (a &lt; other.a);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">bool</span> <a class="code" href="group__pair.html#ga3e678bbdc25d204db143cd5b6db61d97">operator &gt; </a>(<span class="keyword">const</span> MyType&amp; other)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> (a &gt; other.a);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">bool</span> <a class="code" href="group__pair.html#ga0fb42124039c4e0f72525963ef7153f0">operator &gt;= </a>(<span class="keyword">const</span> MyType&amp; other)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> (a &gt;= other.a);</div>
<div class="line">    }</div>
<div class="line">    MyType()</div>
<div class="line">        : a(0) { }</div>
<div class="line">};</div>
<div class="line">);</div>
</div><!-- fragment --><p>After defining the class, user need to register it with BOLT. Internally bolt algorithms will make use of the device_vector class. But these are defined only for the basic data types like int, float, unsigned int etc. For User defined data types it’s the responsibility of the application developer to create a definition of the deveice_vector for his own defined data type. See the below example. </p>
<div class="fragment"><div class="line"><a class="code" href="group__ClCode.html#ga8b9cbe9b8afde5a23262c5f25e3436c2" title="This macro specializes a template with a new type using the template definition of a previously defin...">BOLT_TEMPLATE_REGISTER_NEW_TYPE</a>( bolt::cl::greater, <span class="keywordtype">int</span>, MyType&lt; int&gt; );</div>
<div class="line"><a class="code" href="group__ClCode.html#ga012279644d3227bf7ff71dc62c4635b7" title="This macro specializes a template iterator with a new type using the template definition of a previou...">BOLT_TEMPLATE_REGISTER_NEW_ITERATOR</a>( <a class="code" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">bolt::cl::device_vector</a>, <span class="keywordtype">int</span>, MyType&lt; int&gt; );</div>
</div><!-- fragment --><p> In the above example bolt::cl::greater functor is defined in <a class="el" href="cl_2functional_8h.html" title="List all the unary and binary functions.">include/bolt/cl/functional.h</a>. For the user defined data types it is the responsibility of the application developer to define as shown above for the functors which he uses from <a class="el" href="cl_2functional_8h.html" title="List all the unary and binary functions.">include/bolt/cl/functional.h</a> .</p>
<p>Stitching it all together with a below sample code for Sort: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">typedef</span> MyType&lt;int&gt; mytype;</div>
<div class="line">    std::vector&lt;mytype&gt; myTypeBoltInput(length);</div>
<div class="line">    <a class="code" href="group__CL-sort.html#ga7720660d4a8dee06ea5314d3a1db7db3" title="This version of sort returns the sorted result of all the elements in the RandomAccessIterator betwee...">bolt::cl::sort</a>(myTypeBoltInput.begin(), myTypeBoltInput.end(),bolt::cl::greater&lt;mytype&gt;());</div>
<div class="line">}</div>
</div><!-- fragment --><p>User can also work with his own defined Functor as shown below: </p>
<div class="fragment"><div class="line"><a class="code" href="group__ClCode.html#ga2478d544fdd6b2cb0b1104ee5378a177">BOLT_FUNCTOR</a>(uddtD4,</div>
<div class="line"><span class="keyword">struct</span> uddtD4</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">double</span> a;</div>
<div class="line">    <span class="keywordtype">double</span> b;</div>
<div class="line">    <span class="keywordtype">double</span> c;</div>
<div class="line">    <span class="keywordtype">double</span> d;</div>
<div class="line">  </div>
<div class="line">};</div>
<div class="line">);</div>
<div class="line"><span class="comment">// Functor for UDD. Adds all four double elements and returns true if lhs_sum &gt; rhs_sum</span></div>
<div class="line"><a class="code" href="group__ClCode.html#ga2478d544fdd6b2cb0b1104ee5378a177">BOLT_FUNCTOR</a>(AddD4,</div>
<div class="line"><span class="keyword">struct</span> AddD4</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> uddtD4 &amp;lhs, <span class="keyword">const</span> uddtD4 &amp;rhs)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span>( ( lhs.a + lhs.b + lhs.c + lhs.d ) &gt; ( rhs.a + rhs.b + rhs.c + rhs.d) )</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    };</div>
<div class="line">}; </div>
<div class="line">);</div>
<div class="line"><span class="keywordtype">void</span> main()</div>
<div class="line">{</div>
<div class="line">    std::vector &lt;uddtD4&gt; boltInput(sizeOfInputBuffer);</div>
<div class="line">    <a class="code" href="group__CL-sort.html#ga7720660d4a8dee06ea5314d3a1db7db3" title="This version of sort returns the sorted result of all the elements in the RandomAccessIterator betwee...">bolt::cl::sort</a>( boltInput.begin( ), boltInput.end( ), AddD4() );</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="subexample2_sec"></a>
Templatized Bolt Functor</h2>
<p>User can also use Templatized version of Bolt Functor with User defined data types as shown below:</p>
<div class="fragment"><div class="line"><a class="code" href="group__ClCode.html#ga7f21e1fb33d54ecc5adaeca8b4a05b45">BOLT_TEMPLATE_FUNCTOR1</a>( MyFunctor,  <span class="keywordtype">int</span></div>
<div class="line">template &lt;typename T&gt;    </div>
<div class="line"><span class="keyword">struct</span> MyFunctor{ </div>
<div class="line">    T a; </div>
<div class="line">    T b; </div>
<div class="line">    <span class="keywordtype">bool</span> operator() (<span class="keyword">const</span> MyFunctor&amp; lhs, <span class="keyword">const</span> MyFunctor&amp; rhs)<span class="keyword"> const </span>{ </div>
<div class="line">        <span class="keywordflow">return</span> (lhs.a &gt; rhs.a);</div>
<div class="line">    } </div>
<div class="line">    <span class="keywordtype">bool</span> <a class="code" href="group__pair.html#gafd150c808efd3e9205b069bf3f62f3ea">operator &lt; </a>(<span class="keyword">const</span> MyFunctor&amp; other)<span class="keyword"> const </span>{ </div>
<div class="line">        <span class="keywordflow">return</span> (a &lt; other.a);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">bool</span> <a class="code" href="group__pair.html#ga3e678bbdc25d204db143cd5b6db61d97">operator &gt; </a>(<span class="keyword">const</span> MyFunctor&amp; other)<span class="keyword"> const </span>{ </div>
<div class="line">        <span class="keywordflow">return</span> (a &gt; other.a);</div>
<div class="line">    }</div>
<div class="line">    MyFunctor(<span class="keyword">const</span> MyFunctor &amp;other) </div>
<div class="line">        : a(other.a), b(other.b) { } </div>
<div class="line">    MyFunctor() </div>
<div class="line">        : a(0), b(0) { } </div>
<div class="line">    MyFunctor(T&amp; _in) </div>
<div class="line">        : a(_in), b(_in) { } </div>
<div class="line">}; </div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__ClCode.html#ga8b9cbe9b8afde5a23262c5f25e3436c2" title="This macro specializes a template with a new type using the template definition of a previously defin...">BOLT_TEMPLATE_REGISTER_NEW_TYPE</a>( bolt::cl::greater, <span class="keywordtype">int</span>, MyFunctor&lt; int&gt; );</div>
<div class="line"><a class="code" href="group__ClCode.html#ga012279644d3227bf7ff71dc62c4635b7" title="This macro specializes a template iterator with a new type using the template definition of a previou...">BOLT_TEMPLATE_REGISTER_NEW_ITERATOR</a>( <a class="code" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">bolt::cl::device_vector</a>, <span class="keywordtype">int</span>, MyFunctor&lt; int&gt; );</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">typedef</span> MyFunctor&lt;int&gt; myfunctor;</div>
<div class="line">    std::vector &lt;myfunctor&gt; boltInput(sizeOfInputBuffer);</div>
<div class="line">    <a class="code" href="group__CL-sort.html#ga7720660d4a8dee06ea5314d3a1db7db3" title="This version of sort returns the sorted result of all the elements in the RandomAccessIterator betwee...">bolt::cl::sort</a>( boltInput.begin( ), boltInput.end( ), bolt::cl::greater&lt;myfunctor&gt;() );</div>
<div class="line">}</div>
</div><!-- fragment --><p> If the user wants to use TEMPLATE_FUNCTOR for more than one datatype then he can use other variants of this like BOLT_TEMPLATE_FUNCTOR2, BOLT_TEMPLATE_FUNCTOR3 etc from <a class="el" href="clcode_8h.html" title="Defines macros to help the user create code with C++ semantics for OpenCL kernels.">include/bolt/cl/clcode.h</a> file.</p>
<h1><a class="anchor" id="Function_Path"></a>
Supported Functions and Code Paths</h1>
<p>List of <a href="supportedFunction.html">Supported Functions and Code Paths</a>. </p>
<h2><a class="anchor" id="paths"></a>
Code Path Behaviour</h2>
<h3><a class="anchor" id="Default"></a>
Default Behaviour</h3>
<p>Bolt function can be executed with three code paths(OpenCL™, Multicore CPU and Serial). The default mode is "Automatic" which means it will go into OpenCL&trade; path first, then TBB (Intel), then SerialCpu with below mentioned order. The control will go to other paths only if the selected one not found.</p>
<p>Selection order will be: </p>
<ul>
<li>Run on GPU if AMD GPU is found and AMD APP SDK is installed. </li>
<li>Run on Multicore CPU if Intel TBB is installed. </li>
<li>Run CPU serial path.</li>
</ul>
<h3><a class="anchor" id="Force"></a>
Force Behaviour</h3>
<p>Forcing mode to any device will run the function on that device only. There are two ways in BOLT to force the control to specific Device.</p>
<ol type="1">
<li><b> Setting control to Device Globally: </b> <div class="fragment"><div class="line"><a class="code" href="classbolt_1_1cl_1_1control.html">bolt::cl::control</a>&amp; myControl = <a class="code" href="group__CL-control.html#ga59712ff5a77d3714f716d85938705289">bolt::cl::control::getDefault</a>( );</div>
<div class="line">  myControl.waitMode( bolt::cl::control::NiceWait );</div>
<div class="line">  myControl.<a class="code" href="group__CL-control.html#gab2ae4ea074dd26814f6356d884cc2146">setForceRunMode</a>( bolt::cl::control::OpenCL );</div>
</div><!-- fragment --></li>
<li><b> Setting control to Device locally </b> <div class="fragment"><div class="line"><a class="code" href="classbolt_1_1amp_1_1control.html">bolt::amp::control</a> ctl = <a class="code" href="group__control.html#gaffa8e713ecb8bd1ee469c3565e046a62">bolt::amp::control::getDefault</a>( );</div>
<div class="line"> ctl.<a class="code" href="group__control.html#ga3e51894078b4d33db3aa97fc30ac24b4">setForceRunMode</a>(bolt::amp::control::OpenCL);</div>
</div><!-- fragment --> This will set the control to specified device locally, passing this control object to BOLT function enables specified device path only for that function, so reference to any BOLT function will always run specified device path.</li>
</ol>
<h1><a class="anchor" id="Requirements"></a>
Requirements</h1>
<p>Bolt requires an OpenCL<sup>TM</sup> implementation that supports the static C++ kernel features; specifically, C++ template support for OpenCL<sup>TM</sup> kernels. Currently, the AMD OpenCL<sup>TM</sup> SDK 2.7 provides this support; other vendors may adopt this feature in the future. If you face any issue with any AMD HD7000 family of cards and APU(Richland and Trinity). Please log an issue in <a href="https://github.com/HSA-Libraries/bolt/issues">BOLT Issues page</a>. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jun 20 2013 16:52:48 for Bolt by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3
</small></address>
</body>
</html>
